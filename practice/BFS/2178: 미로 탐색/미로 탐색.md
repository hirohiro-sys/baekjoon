### 問題リンク
https://www.acmicpc.net/problem/2178

### 解き方
最も基本的な幅優先探索問題の1つ。

近い点から網羅的に探索するという幅優先探索の考え方を利用しながら1の箇所を探索していけば解ける。

### コード
```python
from collections import deque

n,m = map(int,input().split())
a = [list(map(int,input())) for _ in range(n)]

dire = [(-1,0),(1,0),(0,-1),(0,1)]
queue = deque([(0,0)])
# 別に関数化させなくてもいい
def bfs():
    while queue:
        x,y = queue.popleft()
        for i in range(len(dire)):
            dx = x + dire[i][0]
            dy = y + dire[i][1]
            if 0<=dx<n and 0<=dy<m:
                if a[dx][dy]==1:
                    a[dx][dy] = a[x][y] + 1
                    queue.append((dx,dy))

bfs()
print(a[n-1][m-1])
```
